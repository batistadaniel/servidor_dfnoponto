<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DF No Ponto 2.0 ü§ôüèæ</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body,html,#map{height:100%}
  #map{width:100%}

  /* PADRONIZA√á√ÉO DAS LEGENDAS */
  .line-label {
    display:inline-block;
    transform: translate(-50%,-50%);
    white-space: nowrap;
    cursor: pointer;
    font-weight:700;
    text-align:center;
    line-height:1.2;
    padding:2px 4px;
    border:2.5px solid #000;
    font-size:12px;
    border-radius:6px;
  }

  .leaflet-popup-content { font-family: Arial, sans-serif; font-size:13px; }

  /* Caixa de pesquisa no lado direito */
  .search-container {
    position: absolute;
    top: 16px;
    right: 16px;
    z-index: 99999;
    width: 300px;
    font-family: Arial, sans-serif;
  }
  @media (min-width:768px){
    .search-container{ width: 400px; }
  }
  #search {
    width: 100%;
    height: 50px;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 20px;
    outline: 1px solid gray;
  }
  .suggestions {
    background: #fff;
    border: 1px solid #ccc;
    border-top: none;
    max-height: 250px;
    overflow-y: auto;
    border-radius: 0 0 4px 4px;
    display: none;
  }
  .suggestion-item { padding: 6px 10px; cursor: pointer; }
  .suggestion-item:hover { background: #f0f0f0; }

  .search-tags {
    display:flex;
    flex-wrap:wrap;
    margin-top:5px;
  }
  .tag {
    background:#0077b6;
    color:white;
    padding:4px 8px;
    margin:2px;
    border-radius:4px;
    font-weight: bold;
    cursor:pointer;
    user-select:none;
  }

  .filtro-container{
    position:absolute;
    bottom:30px;
    right:12px;
    background:#fff;
    padding:10px 12px;
    border-radius:10px;
    box-shadow:0 2px 10px rgba(0,0,0,0.15);
    z-index:99999;
    font-family:Arial, sans-serif;
    font-size:14px;
  }
  .filtro-container label{display:block;margin:4px 0}
</style>
<style>
  .hover-tooltip {
    background: rgba(255,255,255,0.95);
    color: #000;
    border: 1px solid rgba(0,0,0,0.2);
    padding: 4px 8px;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    font-weight: 700;
  }
</style>
</head>
<body>
<div class="search-container">
  <input type="text" id="search" placeholder="Pesquisar linha ou prefixo..." />
  <div id="suggestions" class="suggestions"></div>
  <div id="search-tags" class="search-tags"></div>
</div>

<div id="map"></div>

<div class="filtro-container">
  <label><input id="todos" type="checkbox" checked> Exibir todos</label>
  <label><input class="empresa" type="checkbox" value="PIRACICABANA" checked> PIRACICABANA</label>
  <label><input class="empresa" type="checkbox" value="PIONEIRA" checked> PIONEIRA</label>
  <label><input class="empresa" type="checkbox" value="URBI" checked> URBI</label>
  <label><input class="empresa" type="checkbox" value="MARECHAL" checked> MARECHAL</label>
  <label><input class="empresa" type="checkbox" value="BSBUS" checked> BSBUS</label>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>

let linhaAtivaBorda = null;
let linhaAtivaCor = null;
let dadosTracado = null;

async function carregarTracado() {
  const resp = await fetch("json/tracado_linha.json");
  dadosTracado = await resp.json();
}

carregarTracado();

function desenharTracado(cd_linha, empresa, sentidoApi){
  if (!dadosTracado) return;

  // limpar tra√ßado anterior
  if (linhaAtivaBorda) { map.removeLayer(linhaAtivaBorda); linhaAtivaBorda = null; }
  if (linhaAtivaCor) { map.removeLayer(linhaAtivaCor); linhaAtivaCor = null; }

  if(!cd_linha) return;

  // filtra todos os registros do json para a linha
  const candidatos = dadosTracado.filter(x => String(x.cd_linha) === String(cd_linha));
  if(!candidatos || candidatos.length === 0) return;

  // fun√ß√£o auxiliar para mapear sentidoApi ('0' => 'IDA','1' => 'VOLTA')
  function mapSentidoApi(s){ if(s === '0') return 'IDA'; if(s === '1') return 'VOLTA'; return null; }
  const sentidoMapeado = mapSentidoApi(String(sentidoApi));

  // priorizar correspond√™ncia exata por sentido_linha
  let item = null;
  if(sentidoMapeado){
    item = candidatos.find(c => String(c.sentido_linha).toUpperCase() === sentidoMapeado);
  }
  // se n√£o achou, tentar pegar CIRCULAR (se existir)
  if(!item){
    item = candidatos.find(c => String(c.sentido_linha).toUpperCase() === 'CIRCULAR');
  }
  // fallback para qualquer registro da linha
  if(!item) item = candidatos[0];

  if(!item) return;

  let coords;
  try {
    coords = JSON.parse(item.tracado_linha);
  } catch (e) {
    console.error("Erro ao converter tracado_linha:", e);
    return;
  }

  const corEmpresa = coresEmpresas[empresa] || "#0080ff";

  linhaAtivaBorda = L.polyline(coords, {
    color: "black",
    weight: 5,
    opacity: 1
  }).addTo(map);

  linhaAtivaCor = L.polyline(coords, {
    color: corEmpresa,
    weight: 3,
    opacity: 1
  }).addTo(map);

  // permitir fechar o tracado clicando sobre ele
  try{
    linhaAtivaBorda.on('click', function(){
      selectedLinha = null;
      aplicarFiltroPorLinha(null);
      limparTracado();
    });
  }catch(e){}
  try{
    linhaAtivaCor.on('click', function(){
      selectedLinha = null;
      aplicarFiltroPorLinha(null);
      limparTracado();
    });
  }catch(e){}

  // tornar as polylines interativas para permitir fechar clicando nelas
  try{
    linhaAtivaBorda.on('click', function(e){
      selectedLinha = null;
      aplicarFiltroPorLinha(null);
      limparTracado();
    });
  }catch(e){}
  try{
    linhaAtivaCor.on('click', function(e){
      selectedLinha = null;
      aplicarFiltroPorLinha(null);
      limparTracado();
    });
  }catch(e){}

  // expandir mapa para bounds do tra√ßado
  try{ map.fitBounds(linhaAtivaCor.getBounds()); }catch(e){}
}

// sele√ß√£o por n√∫mero de linha (adicionado)
let selectedLinha = null; // cd_linha selecionada (string) ou null

function limparTracado(){
  if (linhaAtivaBorda) { map.removeLayer(linhaAtivaBorda); linhaAtivaBorda = null; }
  if (linhaAtivaCor) { map.removeLayer(linhaAtivaCor); linhaAtivaCor = null; }
}

function aplicarFiltroPorLinha(cd_linha){
  // Se cd_linha for null -> restaura todos (addTo map)
  // Caso contr√°rio, mostra apenas markers cuja propriedade _cd_linha === cd_linha
  for(const id in fullMarkers){
    const m = fullMarkers[id];
    if(!m) continue;
    try{
      if(!cd_linha || String(m._cd_linha) === String(cd_linha)){
        if(!map.hasLayer(m)) m.addTo(map);
      } else {
        if(map.hasLayer(m)) map.removeLayer(m);
      }
    }catch(e){ /* ignore */ }
  }
  for(const key in smallMarkers){
    const m = smallMarkers[key];
    if(!m) continue;
    try{
      if(!cd_linha || String(m._cd_linha) === String(cd_linha)){
        if(!map.hasLayer(m)) m.addTo(map);
      } else {
        if(map.hasLayer(m)) map.removeLayer(m);
      }
    }catch(e){ /* ignore */ }
  }
}

function selecionarLinha(cd_linha, empresa, sentido){
  // togglear sele√ß√£o: se clicar na mesma linha, limpa sele√ß√£o
  if(!cd_linha){
    selectedLinha = null;
    aplicarFiltroPorLinha(null);
    limparTracado();
    return;
  }
  if(selectedLinha && String(selectedLinha) === String(cd_linha)){
    // j√° selecionada -> limpar
    selectedLinha = null;
    aplicarFiltroPorLinha(null);
    limparTracado();
  } else {
    selectedLinha = String(cd_linha);
    aplicarFiltroPorLinha(selectedLinha);
    // desenhar tracado usando a empresa do clique para colorir
    desenharTracado(cd_linha, empresa, sentido);
  }
}



/* --- configs (mantive seus valores) --- */
const DATA_URL = "http://localhost:3000/api/geojson";
const ZOOM_THRESHOLD_FULL = 13;
const CELL_SIZE_PX = 60;
const REFRESH_MS = 3000;

const map = L.map('map').setView([-15.8, -47.9], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'¬© OpenStreetMap' }).addTo(map);

// clicar no mapa (fora) limpa sele√ß√£o/tracado e restaura marcadores
map.on('click', function(){
  selectedLinha = null;
  aplicarFiltroPorLinha(null);
  limparTracado();
});

// atalho ESC para limpar sele√ß√£o/tracado
document.addEventListener('keydown', function(e){
  if(e.key === 'Escape'){
    selectedLinha = null;
    aplicarFiltroPorLinha(null);
    limparTracado();
  }
});

const fullMarkers = {};   // id -> marker
const smallMarkers = {};  // cellKey -> marker
const idToCell = {};      // id -> cellKey (for small mode)
let popupInfo = { id: null, marker: null };
const lastUpdateTimes = {};
let fullMarkersData = [];
let searchTerms = [];

const coresEmpresas = {
  "PIRACICABANA": "#ff1e00",
  "PIONEIRA": "#ffd500",
  "URBI": "#0080ff",
  "MARECHAL": "#ff9100",
  "BSBUS": "#4dff00"
};

function empresaPorPrefixo(numero){
  const s = String(numero||'');
  switch(s.charAt(0)){
    case '1': return 'PIRACICABANA';
    case '2': return 'PIONEIRA';
    case '3': return 'URBI';
    case '4': return 'MARECHAL';
    case '5': case '7': return 'BSBUS';
    default: return 'DESCONHECIDO';
  }
}

function formatarTempo(segundos){
  const dias = Math.floor(segundos/86400);
  const horas = Math.floor((segundos%86400)/3600);
  const minutos = Math.floor((segundos%3600)/60);
  const seg = segundos%60;
  if(dias>0) return `${dias}d ${horas}h ${minutos}m ${seg}s`;
  if(horas>0) return `${horas}h ${minutos}m ${seg}s`;
  if(minutos>0) return `${minutos}m ${seg}s`;
  return `${seg}s`;
}

function formatarDataHora(datalocal) {
  if (!datalocal) return { data: "‚Äî", hora: "‚Äî" };

  const d = new Date(datalocal);

  // Formatar data dd/mm/aaaa
  const dia = String(d.getDate()).padStart(2, "0");
  const mes = String(d.getMonth() + 1).padStart(2, "0");
  const ano = d.getFullYear();

  const data = `${dia}/${mes}/${ano}`;

  // Formatar hora hh:mm:ss
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");

  const hora = `${hh}:${mm}:${ss}`;

  return { data, hora };
}



/* Mantive exatamente sua estrutura de popup (s√≥ que sem destruir quando atualiza) */
function criarConteudoPopup(prefixo, cd_linha, empresa, id){
  const tempo = lastUpdateTimes[id] ? formatarTempo(Math.floor((Date.now()-lastUpdateTimes[id])/1000)) : 'calculando...';

  // pegar datalocal original do feature
  let datalocalOriginal = null;
  let sentidoOriginal = null; // valor vindo da API: '0','1' ou ''
  for (const f of fullMarkersData) {
    if (String(f.properties.prefixo) === String(id)) {
      datalocalOriginal = f.properties.datalocal;
      sentidoOriginal = (f.properties.sentido !== undefined && f.properties.sentido !== null) ? String(f.properties.sentido) : '';
      break;
    }
  }

  const { data, hora } = formatarDataHora(datalocalOriginal);

  // determinar texto de sentido consultando o JSON de tra√ßados
  let sentidoTxt = '‚Äî';
  // primeiro, mapear valor da API para texto
  if (sentidoOriginal === '0') sentidoTxt = 'Ida';
  else if (sentidoOriginal === '1') sentidoTxt = 'Volta';

  if (cd_linha && dadosTracado){
    // procurar entradas do json para esta linha
    const candidatos = dadosTracado.filter(x => String(x.cd_linha) === String(cd_linha));
    if(candidatos && candidatos.length){
      // tentar achar registro com sentido_linha IDA/VOLTA conforme API
      const matchApi = candidatos.find(c => {
        const s = String(c.sentido_linha||'').toUpperCase();
        if(sentidoOriginal === '0' && s === 'IDA') return true;
        if(sentidoOriginal === '1' && s === 'VOLTA') return true;
        return false;
      });
      if(matchApi){
        // se achou correspond√™ncia direta, usar s√≥ Ida/Volta
        sentidoTxt = matchApi.sentido_linha;
      } else {
        // se n√£o h√° correspond√™ncia direta, verificar se existe CIRCULAR
        const circ = candidatos.find(c => String(c.sentido_linha||'').toUpperCase() === 'CIRCULAR');
        if(circ){
          // exibir 'CIRCULAR - (Ida)' ou 'CIRCULAR - (Volta)' quando API informar sentido
          if(sentidoOriginal === '0') sentidoTxt = 'CIRCULAR - (Ida)';
          else if(sentidoOriginal === '1') sentidoTxt = 'CIRCULAR - (Volta)';
          else sentidoTxt = 'CIRCULAR';
        } else if(candidatos[0].sentido_linha){
          // fallback para o primeiro registro
          sentidoTxt = candidatos[0].sentido_linha;
        }
      }
    }
  }

  return `
    <div style="text-align:center;">
      <b style="padding-bottom: 6px; display: inline-block;text-align:center;">Linha:</b> ${cd_linha || 'Sem Opera√ß√£o ou <br>Transfer√™ncia'}<br>
    </div> 
    <hr >
    <b style="padding-top: 6px; display: inline-block;">Sentido:</b> ${sentidoTxt}<br>
    <b>Prefixo:</b> ${prefixo}<br>
    <b>Empresa:</b> ${empresa}<br>
    <b>Data:</b> ${data}<br>
    <b>Hor√°rio:</b> ${hora}<br>
    <b>√öltimo sinal:</b> ${tempo} atr√°s
  `;
}


/* bind com comportamento padr√£o: abre popup, ao abrir outro fecha anterior (padr√£o do leaflet) */
function bindAndOpenMarker(marker, id, prefixo, cd_linha, empresa){
  const content = criarConteudoPopup(prefixo, cd_linha, empresa, id);
  try { marker.unbindPopup(); } catch(e){}
  // bind com comportamento default (sem for√ßar autoClose:false)
  marker.bindPopup(content).openPopup();
  // se j√° havia outro popup aberto, deixe o leaflet fechar ele automaticamente
  popupInfo = { id, marker };
}

/* helper para calcular cellKey (mantido) */
function getCellKey(latlng){
  const p = map.project(latlng, map.getZoom());
  const cellX = Math.floor(p.x / CELL_SIZE_PX);
  const cellY = Math.floor(p.y / CELL_SIZE_PX);
  return `${cellX}_${cellY}`;
}

function mapSentidoTxt(s){
  if(s === '0') return 'Ida';
  if(s === '1') return 'Volta';
  return '‚Äî';
}

function attachHoverTooltip(marker, cd_linha_display, sentidoApi){
  try{
    const sentidoTxt = mapSentidoTxt(String(sentidoApi || ''));
    const label = (cd_linha_display === undefined || cd_linha_display === null) ? '‚Äî' : String(cd_linha_display);
    const text = `${label} | ${sentidoTxt}`;
    try { marker.unbindTooltip(); } catch(e){}
    marker.bindTooltip(text, { direction: 'right', offset: [10,0], className: 'hover-tooltip', sticky: true });
    // ensure hover opens/closes tooltip
    marker.off('mouseover.tooltip'); marker.off('mouseout.tooltip');
    marker.on('mouseover.tooltip', ()=>{ try{ marker.openTooltip(); }catch(e){} });
    marker.on('mouseout.tooltip', ()=>{ try{ marker.closeTooltip(); }catch(e){} });
  }catch(e){ /* ignore */ }
}

/* === atualiza√ß√£o de marcadores: evitar destruir tudo === */
async function atualizarMapa(){
  try{
    const resp = await fetch(DATA_URL);
    if(!resp.ok) throw new Error('fetch error');
    const data = await resp.json();
    const features = data.features || [];
    fullMarkersData = features; // para sugest√µes
    const zoom = map.getZoom();
    const fullMode = zoom >= ZOOM_THRESHOLD_FULL;
    const activeEmpresas = Array.from(document.querySelectorAll('.empresa:checked')).map(el=>el.value);

    // filtra conforme empresas e termos de busca
    const filtered = features.filter(f=>{
      const p = f.properties;
      const prefixo = String(p.prefixo || '');
      const linha = String(p.cd_linha || '');
      const empresa = empresaPorPrefixo(prefixo);
      if(!activeEmpresas.includes(empresa)) return false;
      // respeitar sele√ß√£o por linha: se selectedLinha definida, aceitar s√≥ essa linha
      if(selectedLinha && String(linha) !== String(selectedLinha)) return false;
      if(searchTerms.length === 0) return true;
      return searchTerms.some(term => (linha && linha.includes(term)) || (prefixo && prefixo.includes(term)));
    });

    if(fullMode){
      // vamos manter um set dos ids vistos nesta atualiza√ß√£o
      const seen = new Set();

      for(const f of filtered){
        const p = f.properties;
        const prefixo = String(p.prefixo);
        const id = String(prefixo);
        const cd_linha = p.cd_linha;
        const empresa = empresaPorPrefixo(prefixo);
        const lat = parseFloat(p.latitude);
        const lon = parseFloat(p.longitude);
        // guardar sentido original da API (p.sentido pode ser '0','1' ou '')
        const sentidoApi = (p.sentido !== undefined && p.sentido !== null) ? String(p.sentido) : '';
        if(!lat || !lon || lat===0 || lon===0) continue;

        // armazenar tempo em ms (consistente)
        lastUpdateTimes[id] = p.datalocal ? new Date(p.datalocal).getTime() : (lastUpdateTimes[id] || Date.now());

        seen.add(id);
        const color = coresEmpresas[empresa] || '#0077b6';
        const html = `<div class="line-label" style="background:${color}">${cd_linha||'‚Äî'}</div>`;

        // se o marker j√° existe, apenas atualize posi√ß√£o e html
        if(fullMarkers[id]){
          fullMarkers[id].setLatLng([lat, lon]);
          // anexa metadados caso n√£o existam
          fullMarkers[id]._cd_linha = cd_linha;
          fullMarkers[id]._empresa = empresa;
          fullMarkers[id]._prefixo = prefixo;
          fullMarkers[id]._sentido = sentidoApi;

          // atualizar tooltip de hover
          try{ attachHoverTooltip(fullMarkers[id], cd_linha, sentidoApi); }catch(e){}

          // atualiza HTML do divIcon se necess√°rio
          const el = fullMarkers[id].getElement();
          if(el && el.innerHTML !== html){
            // atualizar √≠cone recriando icon ‚Äî manter refer√™ncia marker
            const icon = L.divIcon({ className:'', html, iconSize:[0,0], iconAnchor:[0,0], popupAnchor:[0,-10] });
            fullMarkers[id].setIcon(icon);
          }
          // se o popup atual aberto √© deste id, atualiza conte√∫do para manter "√öltimo sinal"
          if(popupInfo.id === id && popupInfo.marker){
            const popup = fullMarkers[id].getPopup();
            if(popup && popup.isOpen()){
              const content = criarConteudoPopup(prefixo, cd_linha, empresa, id);
              popup.setContent(content);
            }
            // garantir popup segue o marker (se por algum motivo o popup estava ligado ao marker antigo)
            try { fullMarkers[id].openPopup(); } catch(e){}
            popupInfo.marker = fullMarkers[id];
          }
        } else {
          // criar novo marker
          const icon = L.divIcon({ className:'', html, iconSize:[0,0], iconAnchor:[0,0], popupAnchor:[0,-10] });
          const m = L.marker([lat, lon], { icon }).addTo(map);
          // anexa metadados para filtro
          m._cd_linha = cd_linha;
          m._empresa = empresa;
          m._prefixo = prefixo;
          m._sentido = sentidoApi;

          // attach hover tooltip
          try{ attachHoverTooltip(m, cd_linha, sentidoApi); }catch(e){}

          m.on('click', function(evt){
            bindAndOpenMarker(m, id, prefixo, cd_linha, empresa);
            // selecionar apenas linhas com mesmo n√∫mero e desenhar tracado
            selecionarLinha(cd_linha, empresa, sentidoApi);
          });
          fullMarkers[id] = m;

          // se popup estava aberto para esse id (caso raro), reabri-lo no novo marker
          if(popupInfo.id === id){
            // abrir com conte√∫do atualizado
            const content = criarConteudoPopup(prefixo, cd_linha, empresa, id);
            try { m.unbindPopup(); } catch(e){}
            m.bindPopup(content).openPopup();
            popupInfo.marker = m;
          }
        }
      }

      // remover fullMarkers que n√£o foram vistos agora
      for(const id in fullMarkers){
        if(!seen.has(id)){
          // se popup estava no marker que vamos remover, feche e limpe popupInfo
          if(popupInfo.id === id && popupInfo.marker){
            try { popupInfo.marker.closePopup(); } catch(e){}
            popupInfo = { id: null, marker: null };
          }
          map.removeLayer(fullMarkers[id]);
          delete fullMarkers[id];
        }
      }

      // no modo full n√£o mantemos smallMarkers; remova-os
      for(const k in smallMarkers){ map.removeLayer(smallMarkers[k]); delete smallMarkers[k]; }
      for(const k in idToCell){ delete idToCell[k]; }

    } else {
      // modo small: agrega√ß√£o por c√©lula
      const cellMap = {}; // cellKey -> representative
      const idCellMap = {}; // id -> cellKey

      for(const f of filtered){
        const p = f.properties;
        const prefixo = String(p.prefixo);
        const id = String(prefixo);
        const cd_linha = p.cd_linha;
        const empresa = empresaPorPrefixo(prefixo);
        const lat = parseFloat(p.latitude);
        const lon = parseFloat(p.longitude);
        const sentidoApi = (p.sentido !== undefined && p.sentido !== null) ? String(p.sentido) : '';
        if(!lat || !lon || lat===0 || lon===0) continue;

        lastUpdateTimes[id] = p.datalocal ? new Date(p.datalocal).getTime() : (lastUpdateTimes[id] || Date.now());

        const latlng = L.latLng(lat, lon);
        const cellKey = getCellKey(latlng);
        idCellMap[id] = cellKey;

        if(!cellMap[cellKey]){
          cellMap[cellKey] = { id, latlng, cd_linha, empresa, color: coresEmpresas[empresa] || '#0077b6', prefixo, sentido: sentidoApi };
        }
      }

      // sincronizar idToCell (para limpeza)
      for(const id in idToCell){ if(!(id in idCellMap)) delete idToCell[id]; }
      for(const id in idCellMap) idToCell[id] = idCellMap[id];

      // atualizar/criar smallMarkers pelas c√©lulas
      const seenCells = new Set();
      for(const cellKey in cellMap){
        seenCells.add(cellKey);
        const rep = cellMap[cellKey];
        const html = `<div class="line-label" style="background:${rep.color}">${rep.cd_linha||'‚Äî'}</div>`;

        if(smallMarkers[cellKey]){
          smallMarkers[cellKey].setLatLng(rep.latlng);
          // anexa metadados caso n√£o existam
          smallMarkers[cellKey]._cd_linha = rep.cd_linha;
          smallMarkers[cellKey]._empresa = rep.empresa;
          smallMarkers[cellKey]._prefixo = rep.prefixo;
          smallMarkers[cellKey]._sentido = rep.sentido;

          // atualizar tooltip de hover
          try{ attachHoverTooltip(smallMarkers[cellKey], rep.cd_linha, rep.sentido); }catch(e){}

          const el = smallMarkers[cellKey].getElement();
          if(el && el.innerHTML !== html){
            const icon = L.divIcon({ className:'', html, iconSize:[0,0], iconAnchor:[0,0], popupAnchor:[0,-8] });
            smallMarkers[cellKey].setIcon(icon);
          }
          // transfer popup if needed
          if(popupInfo.id === rep.id && popupInfo.marker){
            const popup = smallMarkers[cellKey].getPopup();
            if(popup && popup.isOpen()){
              const content = criarConteudoPopup(rep.prefixo, rep.cd_linha, rep.empresa, rep.id);
              popup.setContent(content);
            }
            try { smallMarkers[cellKey].openPopup(); } catch(e){}
            popupInfo.marker = smallMarkers[cellKey];
          }
        } else {
          const icon = L.divIcon({ className:'', html, iconSize:[0,0], iconAnchor:[0,0], popupAnchor:[0,-8] });
          const m = L.marker(rep.latlng, { icon, interactive:true }).addTo(map);
          // anexa metadados
          m._cd_linha = rep.cd_linha;
          m._empresa = rep.empresa;
          m._prefixo = rep.prefixo;
          m._sentido = rep.sentido;

          // attach hover tooltip
          try{ attachHoverTooltip(m, rep.cd_linha, rep.sentido); }catch(e){}

          m.on('click', ()=> {
            bindAndOpenMarker(m, rep.id, rep.prefixo, rep.cd_linha, rep.empresa);
            // selecionar apenas linhas com mesmo n√∫mero e desenhar tracado
            selecionarLinha(rep.cd_linha, rep.empresa, rep.sentido);
          });
          smallMarkers[cellKey] = m;

          if(popupInfo.id === rep.id){
            const content = criarConteudoPopup(rep.prefixo, rep.cd_linha, rep.empresa, rep.id);
            try { m.unbindPopup(); } catch(e){}
            m.bindPopup(content).openPopup();
            popupInfo.marker = m;
          }
        }
      }

      // remover smallMarkers que n√£o existem mais
      for(const key in smallMarkers){
        if(!seenCells.has(key)){
          // if popup was on it, close
          const marker = smallMarkers[key];
          if(popupInfo.marker === marker){
            try { marker.closePopup(); } catch(e){}
            popupInfo = { id: null, marker: null };
          }
          map.removeLayer(marker);
          delete smallMarkers[key];
        }
      }

      // remove fullMarkers if any (we're in small mode)
      for(const id in fullMarkers){
        if(fullMarkers[id]){
          map.removeLayer(fullMarkers[id]);
          delete fullMarkers[id];
        }
      }
    }

  } catch(err){
    console.error('Erro atualizarMapa', err);
  }
}

/* Atualiza o texto "√öltimo sinal" do popup aberto sem fechar o popup */
/* Usa popupInfo e o popup que est√° ligado ao marker atual */
setInterval(()=>{
  if(popupInfo.id && popupInfo.marker && lastUpdateTimes[popupInfo.id]){
    const popup = popupInfo.marker.getPopup();
    if(popup && popup.isOpen()){
      const segundos = Math.floor((Date.now()-lastUpdateTimes[popupInfo.id])/1000);
      const tempo = formatarTempo(segundos);
      const content = criarConteudoPopup(popupInfo.id, '', /* placeholder linha n√£o usada aqui */ '', popupInfo.id);
      // reconstruir conte√∫do completo (mantendo seu formato original)
      // Para garantir que linha/empresa fiquem corretos, tentamos encontrar dados no fullMarkersData
      let prefixo = popupInfo.id;
      let cd_linha = '‚Äî';
      let empresa = '‚Äî';
      for(const f of fullMarkersData){
        const p = f.properties;
        if(String(p.prefixo) === popupInfo.id){
          prefixo = p.prefixo;
          cd_linha = p.cd_linha || 'Sem Opera√ß√£o ou <br>Transfer√™ncia';
          empresa = empresaPorPrefixo(prefixo);
          break;
        }
      }
      const newContent = `<b>Linha:</b> ${cd_linha}<br>
          <hr>
          <b>Prefixo:</b> ${prefixo}<br>
          <b>Empresa:</b> ${empresa}<br>
          <b>Data:</b> ${data}<br>
          <b>Hor√°rio:</b> ${hora}<br>
          <b>√öltimo sinal:</b> ${tempo} atr√°s`;
      popup.setContent(newContent);
    }
  }
},1000);

/* Manter comportamento esperado ao fechar popup: limpar refer√™ncia */
map.on('popupclose', function(e){
  // se popup fechado manualmente, limpar popupInfo se for o mesmo
  if(popupInfo.marker && e.popup === popupInfo.marker.getPopup()){
    popupInfo = { id: null, marker: null };
  }
});

/* Ao clicar no mapa, deixar o popup fechar (comportamento padr√£o) */
/* N√£o precisamos adicionar handler ‚Äî Leaflet fecha popups ao clicar no mapa por padr√£o. */
/* Por√©m se voc√™ tiver custom handlers antes, assegure-se que n√£o impe√ßam o closeOnClick padr√£o. */

/* --- filtros e pesquisa (mantidos iguais ao seu c√≥digo) --- */

document.querySelectorAll('.empresa').forEach(chk=>chk.addEventListener('change', atualizarMapa));
document.getElementById('todos').addEventListener('change', e=>{
  const val = e.target.checked;
  document.querySelectorAll('.empresa').forEach(c=>c.checked = val);
  atualizarMapa();
});

const searchInput = document.getElementById('search');
const suggestionsBox = document.getElementById('suggestions');
const tagsContainer = document.getElementById('search-tags');

function getSearchOptions(features){
  const set = new Set();
  features.forEach(f => {
    const p=f.properties;
    if(p.cd_linha) set.add(String(p.cd_linha));
    if(p.prefixo) set.add(String(p.prefixo));
  });
  return Array.from(set);
}

function atualizarTagsUI(){
  tagsContainer.innerHTML = '';
  searchTerms.forEach(term=>{
    const div = document.createElement('div');
    div.className = 'tag';
    div.innerText = term + ' √ó';
    div.dataset.term = term;
    tagsContainer.appendChild(div);
  });
}

tagsContainer.addEventListener('click', e=>{
  if(e.target.classList.contains('tag')){
    const term = e.target.dataset.term;
    searchTerms = searchTerms.filter(t=>t!==term);
    atualizarTagsUI();
    atualizarMapa();
  }
});

searchInput.addEventListener('input', ()=>{
  const val = searchInput.value.trim();
  if(!val){ suggestionsBox.style.display='none'; return; }
  const options = getSearchOptions(fullMarkersData).filter(x=>x.includes(val));
  suggestionsBox.innerHTML = options.map(x=>`<div class="suggestion-item">${x}</div>`).join('');
  suggestionsBox.style.display = options.length? 'block':'none';
});

suggestionsBox.addEventListener('click', e=>{
  if(e.target.classList.contains('suggestion-item')){
    const val = e.target.innerText;
    if(!searchTerms.includes(val)) searchTerms.push(val);
    searchInput.value = '';
    suggestionsBox.style.display = 'none';
    atualizarTagsUI();
    atualizarMapa();
  }
});

map.on('zoomend', atualizarMapa);
map.on('moveend', atualizarMapa);

/* bootstrap */
atualizarMapa();
setInterval(atualizarMapa, REFRESH_MS);
</script>
</body>
</html>